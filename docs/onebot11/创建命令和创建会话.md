# 创建命令

目前ROB有2中创建命令的方式:

1. 继承`BaseCommand`来重写必要的属性/需要的方法
2. 通过dsl的写法

## 继承

```kotlin
class EchoCommand : BaseCommand() {
    override val commandNames = listOf("/echo", "/eee")

    override suspend fun executeGroup(message: GroupMessage, args: List<String>) {
        println(message)
    }
}
```

## DSL

```kotlin
suspend fun main() {
    OneBotFactory.commandManager {
        groupCommand(listOf("/te")) {
            println(it)
        }
        privateCommand(listOf("/te")) {
            println(it)
        }
    }
}
```

# 注册命令

## 继承

```kotlin
suspend fun main() {
    OneBotFactory.commandManager.register(EchoCommand())
}
```

## DSL

写完之后就会自动注册了

# 创建会话

在ROB版本大于`3.2.0`以上可以使用新版的`Session` (Java不可用)

```kotlin
class TestCommand : BaseCommand() {
    override val commandNames = listOf("test")

    /**
     * 创建一个群聊会话
     * 在群内发送 test start即可开启
     * 发送 test end将会结束会话
     */
    @OptIn(ExperimentalROneBotApi::class)
    override suspend fun executeGroup(message: GroupMessage, args: List<String>) {
        if (message.text.contains("start")) {
            println("start")
            startGroupSession(message) {
                println(it.message)
                if (it.message.text.contains("end")) {
                    // 结束会话并回复一条消息, 可选是否回复
                    it.accept()  // 直接结束
                    it.accept("ended")  // 结束并回复一条消息
                } else {
                    // 拒绝这次的输入， 下次输入lambda将会重新执行
                    it.reject(Text("reject").toMessageChain())
                }
            }
            // 下面的代码在会话结束前不会执行
            println("ended")
        }
    }

    /**
     * 创建私聊会话
     * 触发方式、逻辑和群聊一致
     */
    @OptIn(ExperimentalROneBotApi::class)
    override suspend fun executePrivate(message: PrivateMessage, args: List<String>) {
        if (message.text.contains("start")) {
            println("start")
            startPrivateSession(message) {
                println(it.message)
                if (it.message.text.contains("end")) {
                    it.accept("ended")
                } else {
                    it.reject(Text("reject").toMessageChain())
                }
            }
            println("ended")
        }
    }
}
```